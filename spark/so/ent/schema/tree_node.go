package schema

import (
	"context"
	"fmt"

	"entgo.io/ent"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"entgo.io/ent/schema/index"
	"github.com/lightsparkdev/spark/common"
	"github.com/lightsparkdev/spark/common/btcnetwork"
	"github.com/lightsparkdev/spark/common/keys"
	gen "github.com/lightsparkdev/spark/so/ent"
	"github.com/lightsparkdev/spark/so/ent/hook"
	st "github.com/lightsparkdev/spark/so/ent/schema/schematype"
	"github.com/lightsparkdev/spark/so/entexample"
)

// TreeNode is the schema for the tree nodes table.
type TreeNode struct {
	ent.Schema
}

// Mixin is the mixin for the tree nodes table.
func (TreeNode) Mixin() []ent.Mixin {
	return []ent.Mixin{
		BaseMixin{},
	}
}

// Fields are the fields for the tree nodes table.
func (TreeNode) Fields() []ent.Field {
	return []ent.Field{
		field.Uint64("value").
			Immutable().
			Comment("Bitcoin value in satoshis for this node.").
			Annotations(entexample.Default(2)),
		field.Enum("network").
			GoType(btcnetwork.Unspecified).
			Immutable().
			Comment("Bitcoin network this node belongs to (Mainnet, Testnet, Regtest).").
			Annotations(entexample.Default(btcnetwork.Regtest)),
		field.Enum("status").
			GoType(st.TreeNodeStatus("")).
			Comment("Current state of the node (e.g., AVAILABLE, TRANSFER_LOCKED, SPLITTED, ON_CHAIN).").
			Annotations(entexample.Default(st.TreeNodeStatusAvailable)),
		field.Bytes("verifying_pubkey").
			Immutable().
			GoType(keys.Public{}).
			Comment("Aggregated public key (user + SE) that controls spending of this node.").
			Annotations(entexample.Default(
				"023f6e31741d42deac29b3895303a35a964f822982f3576664cd838e007001922b",
			)),
		field.Bytes("owner_identity_pubkey").
			GoType(keys.Public{}).
			Comment("User's identity public key that owns this node.").
			Annotations(entexample.Default(
				"02e6858515f7f886842537c752983fa3c3bc7f4b7d35057ae1e0477f637551d7e8",
			)),
		field.Bytes("owner_signing_pubkey").
			GoType(keys.Public{}).
			Comment("User's signing public key derived from their identity key for this specific node.").
			Annotations(entexample.Default(
				"02008022cc74b350a1fea49d1cfc2ded422ad1bfe8eeea0f25cb90b02dad091706",
			)),
		field.Int16("vout").
			Comment("Output index of this node in the parent transaction.").
			Annotations(entexample.Default(0)),

		field.Uint64("node_confirmation_height").
			Optional().
			Comment("Block height when this node's transaction was confirmed on-chain, value is set to nil if the node transaction is not confirmed on-chain."),
		field.Uint64("refund_confirmation_height").
			Optional().
			Comment("Block height when the refund transaction was confirmed on-chain, value is set to nil if the refund transaction is not confirmed on-chain."),

		// Node transactions
		field.Bytes("raw_tx").
			NotEmpty().
			Comment("RawTx holds the value of the \"raw_tx\" field. Also sometimes referred to as NodeTx.").
			Annotations(entexample.Default(
				"03000000000101835f6ac90f4652f515742c5ae8d1e3630225820873283372d8ece4f3eec1f657000000000008070040020200000000000000225120106ab6c66560575acbe93d80d698922b4ec07e090e95957adef323cb3443351a00000000000000000451024e730140f6f972d0c6fc75c4414e21e1eef87baab86c239295a6de6c4984c2b5a50d0a8bd120dfd14a327d71ef46c44b7941246c10a9509eebee5ab66543f8fe60050ea100000000",
			)),
		field.Bytes("direct_tx").
			Optional().
			Comment("DirectTx holds the value of the 'direct_tx' field. Also sometimes referred to as DirectNodeTx.").
			Annotations(entexample.Default(
				"03000000000101835f6ac90f4652f515742c5ae8d1e3630225820873283372d8ece4f3eec1f65700000000003a070040010200000000000000225120106ab6c66560575acbe93d80d698922b4ec07e090e95957adef323cb3443351a0140dc3925f7f3727032fbbea9434e3cd302b55c8d239f06f36ef404a6cd90a4166ea0cf8c5b71ec5f998de00f038632df7ccf1068784aacd5d5349f53a2d364684900000000",
			)),
		field.Bytes("direct_from_cpfp_refund_tx").
			Optional().
			Comment("A transaction that the watctower can broadcast on behalf of the user which spends the node tx and pays to the user.").
			Annotations(entexample.Default(
				"0300000000010149e740760c484ca6deedf45083d700273c26d40eeee9f130dedddbacd7063b490000000000520300400102000000000000002251201b3d6c48bdc256ea039a8238f42ad8deba6ee4d80791db22e9d91fd75d74685d014012a9dd37dd95f1f0b81a663aa83a65581adcd7a5212886768783e757e8fc4cbba8b4dc9cdf650b87a1420230c9dae0cb39b6ff95a96395a96fda75424943d09f00000000",
			)),
		field.Bytes("raw_txid").
			Optional().
			GoType(st.TxID{}).
			Comment("Valid transaction ID of the stored node transaction. Generated by hooks from raw_tx.").
			Annotations(entexample.Default(
				"49e740760c484ca6deedf45083d700273c26d40eeee9f130dedddbacd7063b49",
			)),
		field.Bytes("direct_txid").
			Optional().
			GoType(st.TxID{}).
			Comment("Valid transaction ID of the stored direct node transaction. Generated by hooks from direct_tx.").
			Annotations(entexample.Default(
				"c042a47790af0231a37ee72479537dab4a16decbcea4abe77d65f6246af88b91",
			)),
		field.Bytes("direct_from_cpfp_refund_txid").
			Optional().
			GoType(st.TxID{}).
			Comment("Valid transaction ID of the stored direct from CPFP node transaction. Generated by hooks from direct_from_cpfp_refund_tx.").
			Annotations(entexample.Default(
				"54d1f82b345baa3d9b2dd8a02fcf0edf6c86702a33b43bd689ab95a9718e03ac",
			)),

		// Refund transactions
		field.Bytes("raw_refund_tx").
			Optional().
			Comment("A transaction to exit Spark unilaterally. Only leafs have this transaction. Also sometimes referred to as cpfpRefundTx.").
			Annotations(entexample.Default(
				"0300000000010149e740760c484ca6deedf45083d700273c26d40eeee9f130dedddbacd7063b490000000000200300400202000000000000002251201b3d6c48bdc256ea039a8238f42ad8deba6ee4d80791db22e9d91fd75d74685d00000000000000000451024e730140005b94fc65caf9293c1fbedc5ee9d413eea25f20d85b62e5303a7f50dee3d6bb7a333e51de95669460048601599dcf267fc5a3471a7ce98f8290cf20d3a53d3e00000000",
			)),
		field.Bytes("direct_refund_tx").
			Optional().
			Comment("A transaction that the watctower can broadcast on behalf of the user which spends the direct tx and pays to the user.").
			Annotations(entexample.Default(
				"03000000000101c042a47790af0231a37ee72479537dab4a16decbcea4abe77d65f6246af88b910000000000520300400102000000000000002251201b3d6c48bdc256ea039a8238f42ad8deba6ee4d80791db22e9d91fd75d74685d0140d42a73bd03a7fa3f65309e08ca79b17e38251e374caec60d2f5f1eff4456cafcf32b2da96a2a4ad99364585eeb607256655b264cf7aa97f4ce87bd1d831a754400000000",
			)),
		field.Bytes("raw_refund_txid").
			Optional().
			GoType(st.TxID{}).
			Comment("Valid transaction ID of the stored refund transaction. Generated by hooks from raw_refund_tx.").
			Annotations(entexample.Default(
				"46348ca4b7ff497a8e2035cead92ca012b746c514f9b2c6c25bb4d4c2398a6bd",
			)),
		field.Bytes("direct_refund_txid").
			Optional().
			GoType(st.TxID{}).
			Comment("Valid transaction ID of the direct refund transaction. Generated by hooks from direct_refund_tx.").
			Annotations(entexample.Default(
				"7c9cb91704f52a0959125cf87438043c6e55536da0359ef476173f9f33b8af15",
			)),
	}
}

// Edges are the edges for the tree nodes table.
func (TreeNode) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("tree", Tree.Type).
			Unique().
			Required().
			Immutable(),
		edge.To("parent", TreeNode.Type).
			Unique(),
		edge.To("signing_keyshare", SigningKeyshare.Type).
			Unique().
			Required(),
		edge.From("children", TreeNode.Type).Ref("parent"),
	}
}

// Indexes are the indexes for the tree nodes table.
func (TreeNode) Indexes() []ent.Index {
	return []ent.Index{
		index.Edges("parent"),
		index.Edges("tree"),
		index.Edges("signing_keyshare"),
		index.Fields("owner_identity_pubkey"),
		index.Fields("owner_identity_pubkey", "status"),
		index.Fields("node_confirmation_height"),
		index.Fields("refund_confirmation_height"),
		index.Fields("update_time"),
		// TODO(mhr): This is mostly for the backfill and can probably be removed later.
		index.Fields("network"),

		index.Fields("raw_txid").Annotations(
			entsql.IndexWhere("raw_txid is not null"),
		),
		index.Fields("direct_txid").Annotations(
			entsql.IndexWhere("direct_txid is not null"),
		),
		index.Fields("direct_from_cpfp_refund_txid").Annotations(
			entsql.IndexWhere("direct_from_cpfp_refund_txid is not null"),
		),

		index.Fields("raw_refund_txid").Annotations(
			entsql.IndexWhere("raw_refund_txid is not null"),
		),
		index.Fields("direct_refund_txid").Annotations(
			entsql.IndexWhere("direct_refund_txid is not null"),
		),
	}
}

func (TreeNode) Hooks() []ent.Hook {
	return []ent.Hook{
		// Validate that the tree_node's network matches the network of its parent tree
		hook.On(
			func(next ent.Mutator) ent.Mutator {
				return hook.TreeNodeFunc(func(ctx context.Context, m *gen.TreeNodeMutation) (ent.Value, error) {
					network, hasNetwork := m.Network()
					treeID, hasTree := m.TreeID()

					if !hasNetwork || !hasTree {
						return nil, fmt.Errorf("tree node mutation must contain network and tree ID")
					}

					tree, err := m.Client().Tree.Get(ctx, treeID)
					if err != nil {
						return nil, fmt.Errorf("failed to fetch tree: %w", err)
					}

					if tree.Network != network {
						return nil, fmt.Errorf("tree_node network (%s) does not match tree network (%s)", network, tree.Network)
					}

					return next.Mutate(ctx, m)
				})
			},
			ent.OpCreate,
		),
		// Define helper hooks that will populate TXIDs for the tranactions in the mutation.
		// Clearing a field will also clear a corresponding TXID.
		// If a transaction is set to nil the corresponding TXID will be cleared.
		// Be midful that updates on transactions are slower because the DB indexes on TXIDs are also updated.
		// The first hook handles single entity updates and the second hook handles creations.
		// These hooks will not be called if the entity is part of a batch update.
		hook.On(
			func(next ent.Mutator) ent.Mutator {
				return hook.TreeNodeFunc(func(ctx context.Context, m *gen.TreeNodeMutation) (ent.Value, error) {
					err := checkTxids(m)
					if err != nil {
						return nil, err
					}

					nodeID, _ := m.ID()
					rawTxBytes, _ := m.RawTx()
					if rawTxBytes != nil {
						rawTx, err := common.TxFromRawTxBytes(rawTxBytes)
						if err != nil {
							return nil, fmt.Errorf("failed to parse raw_tx for node %s: %w", nodeID, err)
						}
						rawTxid := rawTx.TxHash()
						m.SetRawTxid(st.NewTxID(rawTxid))
					}

					// Handling an update on a field
					// Check that the value was cleared. Ent framework treats this operation differently and does not show that the field is in the mutation (while in fact it is included in the final SQL), so we can not use a field getter to know if the field was cleared.
					if m.DirectTxCleared() {
						// Clear the field if it was cleared
						m.ClearDirectTxid()
					} else {
						if directTxBytes, ok := m.DirectTx(); ok {
							// If the value is set to nil directly, then it means the same as clearing the field
							if directTxBytes == nil {
								m.ClearDirectTxid()
							} else {
								directTx, err := common.TxFromRawTxBytes(directTxBytes)
								if err != nil {
									return nil, fmt.Errorf("failed to parse direct_tx for node %s: %w", nodeID, err)
								}
								directTxid := directTx.TxHash()
								m.SetDirectTxid(st.NewTxID(directTxid))
							}
						}
					}

					if m.DirectFromCpfpRefundTxCleared() {
						m.ClearDirectFromCpfpRefundTxid()
					} else {
						if directFromCpfpRefundTxBytes, ok := m.DirectFromCpfpRefundTx(); ok {
							if directFromCpfpRefundTxBytes == nil {
								m.ClearDirectFromCpfpRefundTxid()
							} else {
								directFromCpfpRefundTx, err := common.TxFromRawTxBytes(directFromCpfpRefundTxBytes)
								if err != nil {
									return nil, fmt.Errorf("failed to parse direct_from_cpfp_refundtx for node %s: %w", nodeID, err)
								}
								directFromCpfpRefundTxid := directFromCpfpRefundTx.TxHash()
								m.SetDirectFromCpfpRefundTxid(st.NewTxID(directFromCpfpRefundTxid))
							}
						}
					}

					if m.RawRefundTxCleared() {
						m.ClearRawRefundTxid()
					} else {
						if rawRefundTxBytes, ok := m.RawRefundTx(); ok {
							if rawRefundTxBytes == nil {
								m.ClearRawRefundTxid()
							} else {
								rawRefundTx, err := common.TxFromRawTxBytes(rawRefundTxBytes)
								if err != nil {
									return nil, fmt.Errorf("failed to parse raw_refund_tx for node %s: %w", nodeID, err)
								}
								rawRefundTxid := rawRefundTx.TxHash()
								m.SetRawRefundTxid(st.NewTxID(rawRefundTxid))
							}
						}
					}

					if m.DirectRefundTxCleared() {
						m.ClearDirectRefundTxid()
					} else {
						if directRefundTxBytes, ok := m.DirectRefundTx(); ok {
							if directRefundTxBytes == nil {
								m.ClearDirectRefundTxid()
							} else {
								directRefundTx, err := common.TxFromRawTxBytes(directRefundTxBytes)
								if err != nil {
									return nil, fmt.Errorf("failed to parse direct_refund_tx for node %s: %w", nodeID, err)
								}
								directRefundTxid := directRefundTx.TxHash()
								m.SetDirectRefundTxid(st.NewTxID(directRefundTxid))
							}
						}
					}
					return next.Mutate(ctx, m)
				})
			},
			ent.OpUpdateOne|ent.OpUpdate,
		),
		// Create ent hook
		hook.On(
			func(next ent.Mutator) ent.Mutator {
				return hook.TreeNodeFunc(func(ctx context.Context, m *gen.TreeNodeMutation) (ent.Value, error) {
					err := checkTxids(m)
					if err != nil {
						return nil, err
					}

					nodeID, _ := m.ID()
					rawTxBytes, _ := m.RawTx()
					rawTx, err := common.TxFromRawTxBytes(rawTxBytes)
					if err != nil {
						return nil, fmt.Errorf("failed to parse raw_tx for node %s: %w", nodeID, err)
					}
					rawTxid := rawTx.TxHash()
					m.SetRawTxid(st.NewTxID(rawTxid))

					// Handling creation is easier because we don't need to check if the value was changed.
					directTxBytes, _ := m.DirectTx()
					if directTxBytes != nil {
						directTx, err := common.TxFromRawTxBytes(directTxBytes)
						if err != nil {
							return nil, fmt.Errorf("failed to parse direct_tx for node %s: %w", nodeID, err)
						}
						directTxid := directTx.TxHash()
						m.SetDirectTxid(st.NewTxID(directTxid))
					}

					directFromCpfpRefundTxBytes, _ := m.DirectFromCpfpRefundTx()
					if directFromCpfpRefundTxBytes != nil {
						directFromCpfpRefundTx, err := common.TxFromRawTxBytes(directFromCpfpRefundTxBytes)
						if err != nil {
							return nil, fmt.Errorf("failed to parse direct_from_cpfp_refundtx for node %s: %w", nodeID, err)
						}
						directFromCpfpRefundTxid := directFromCpfpRefundTx.TxHash()
						m.SetDirectFromCpfpRefundTxid(st.NewTxID(directFromCpfpRefundTxid))
					}

					rawRefundTxBytes, _ := m.RawRefundTx()
					if rawRefundTxBytes != nil {
						rawRefundTx, err := common.TxFromRawTxBytes(rawRefundTxBytes)
						if err != nil {
							return nil, fmt.Errorf("failed to parse raw_refund_tx for node %s: %w", nodeID, err)
						}
						rawRefundTxid := rawRefundTx.TxHash()
						m.SetRawRefundTxid(st.NewTxID(rawRefundTxid))
					}

					directRefundTxBytes, _ := m.DirectRefundTx()
					if directRefundTxBytes != nil {
						directRefundTx, err := common.TxFromRawTxBytes(directRefundTxBytes)
						if err != nil {
							return nil, fmt.Errorf("failed to parse direct_refund_tx for node %s: %w", nodeID, err)
						}
						directRefundTxid := directRefundTx.TxHash()
						m.SetDirectRefundTxid(st.NewTxID(directRefundTxid))
					}
					return next.Mutate(ctx, m)
				})
			},
			ent.OpCreate,
		),
	}
}

// Checks if the txids are set directly.
// This is not allowed because the txids are generated by hooks from the transactions.
func checkTxids(m *gen.TreeNodeMutation) error {
	if _, ok := m.RawTxid(); ok {
		return fmt.Errorf("raw_txid is not allowed to be set directly")
	}
	if _, ok := m.DirectTxid(); ok {
		return fmt.Errorf("direct_txid is not allowed to be set directly")
	}
	if _, ok := m.DirectFromCpfpRefundTxid(); ok {
		return fmt.Errorf("direct_from_cpfp_refund_txid is not allowed to be set directly")
	}
	if _, ok := m.RawRefundTxid(); ok {
		return fmt.Errorf("raw_refund_txid is not allowed to be set directly")
	}
	if _, ok := m.DirectRefundTxid(); ok {
		return fmt.Errorf("direct_refund_txid is not allowed to be set directly")
	}
	return nil
}
