namespace spark_frost {
    [Throws=Error]
    NonceResult frost_nonce(KeyPackage key_package);

    [Throws=Error]
    bytes sign_frost(bytes msg, KeyPackage key_package, SigningNonce nonce, SigningCommitment self_commitment, record<string, SigningCommitment> statechain_commitments, bytes? adaptor_public_key);

    [Throws=Error]
    bytes aggregate_frost(bytes msg, record<string, SigningCommitment> statechain_commitments, SigningCommitment self_commitment, record<string, bytes> statechain_signatures, bytes self_signature, record<string, bytes> statechain_public_keys, bytes self_public_key, bytes verifying_key, bytes? adaptor_public_key);

    boolean validate_signature_share(bytes msg, record<string, SigningCommitment> statechain_commitments, SigningCommitment self_commitment, bytes signature_share, bytes public_share, bytes verifying_key);

    [Throws=Error]
    TransactionResult construct_node_tx(bytes tx, u32 vout, string address, u16 locktime);

    [Throws=Error]
    TransactionResult construct_refund_tx(bytes tx, u32 vout, bytes pubkey, string network, u32 sequence);

    [Throws=Error]
    TransactionResult construct_direct_refund_tx(bytes tx, u32 vout, bytes pubkey, string network, u32 sequence);

    [Throws=Error]
    TransactionResult construct_split_tx(bytes tx, u32 vout, sequence<string> addresses, u16 locktime);

    [Throws=Error]
    DummyTx create_dummy_tx(string address, u64 amount_sats);

    [Throws=Error]
    bytes encrypt_ecies(bytes msg, bytes public_key);

    [Throws=Error]
    bytes decrypt_ecies(bytes encrypted_msg, bytes private_key);

    [Throws=Error]
    bytes get_taproot_pubkey(bytes verifying_pubkey);

    [Throws=Error]
    bytes get_public_key_bytes(bytes private_key_bytes, boolean compressed);

    [Throws=Error]
    boolean verify_signature_bytes(bytes signature, bytes message, bytes pubkey);

    [Throws=Error]
    bytes random_secret_key_bytes();

    // --- Timelock functions ---

    u32 get_timelock_from_sequence(u32 sequence);

    [Throws=Error]
    void check_if_valid_sequence(u32 sequence);

    boolean is_zero_timelock(u32 sequence);

    u32 round_down_to_timelock_interval(u32 timelock, u32 time_lock_interval);

    [Throws=Error]
    TimelockResult next_sequence(u32 curr_sequence, u32 time_lock_interval, u32 direct_timelock_offset);

    // --- Node tx pair and refund tx trio ---

    [Throws=Error]
    NodeTxPairResult construct_node_tx_pair(bytes parent_tx, u32 vout, string address, u32 sequence, u32 direct_sequence, u64 fee_sats);

    [Throws=Error]
    RefundTxTrioResult construct_refund_tx_trio(bytes cpfp_node_tx, bytes? direct_node_tx, u32 vout, bytes receiving_pubkey, string network, u32 sequence, u32 direct_sequence, u64 fee_sats);

    // --- Multi-input sighash ---

    [Throws=Error]
    bytes compute_multi_input_sighash_uniffi(bytes tx, u32 input_index, sequence<bytes> prev_out_scripts, sequence<u64> prev_out_values);

    // --- HTLC functions ---

    [Throws=Error]
    TransactionResult construct_htlc_transaction(bytes node_tx, u32 vout, u32 sequence, bytes payment_hash, bytes hashlock_pubkey, bytes seqlock_pubkey, u32 htlc_sequence, boolean apply_fee, u64 fee_sats, string network);

    [Throws=Error]
    HTLCSpendResult construct_htlc_sender_spend(bytes htlc_tx, bytes destination_pubkey, bytes payment_hash, bytes hashlock_pubkey, bytes seqlock_pubkey, u32 htlc_sequence, u64 fee_sats, string network);

    [Throws=Error]
    HTLCSpendResult construct_htlc_receiver_spend(bytes htlc_tx, bytes destination_pubkey, bytes payment_hash, bytes hashlock_pubkey, bytes seqlock_pubkey, u32 htlc_sequence, u64 fee_sats, string network);
};

[Error]
enum Error {
    "Spark",
};

dictionary SigningNonce {
    bytes hiding;
    bytes binding;
};

dictionary SigningCommitment {
    bytes hiding;
    bytes binding;
};

dictionary NonceResult {
    SigningNonce nonce;
    SigningCommitment commitment;
};

dictionary KeyPackage {
    bytes secret_key;
    bytes public_key;
    bytes verifying_key;
};

dictionary TransactionResult {
    bytes tx;
    bytes sighash;
    sequence<TxInResult> inputs;
};

dictionary TxInResult {
    u32 sequence;
};

dictionary DummyTx {
    bytes tx;
    string txid;
};

dictionary TimelockResult {
    u32 next_sequence;
    u32 next_direct_sequence;
};

dictionary NodeTxPairResult {
    TransactionResult cpfp;
    TransactionResult direct;
};

dictionary RefundTxTrioResult {
    TransactionResult cpfp_refund;
    TransactionResult? direct_refund;
    TransactionResult direct_from_cpfp_refund;
};

dictionary HTLCSpendResult {
    bytes tx;
    bytes sighash;
    bytes script;
    bytes control_block;
};
